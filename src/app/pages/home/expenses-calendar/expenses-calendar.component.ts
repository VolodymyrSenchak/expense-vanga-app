import {Component, computed, input, output, signal} from '@angular/core';
import {CurrentExpensesModel, ExpenseForDay} from '@common/models/current-expenses.model';
import {DATE_UTILS} from '@common/utils/date.utils';
import {LoadingComponent} from '@components/loading';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { BaseExpensesListComponent } from '../base-expenses-list';
import { ExpensesDetailsHeaderComponent } from '../expenses-details-header';
import { DesktopViewMode } from '@common/models';

interface ExpenseForDayWrapper {
  monthDay: number;
  autogenerated?: boolean;
  isWeekend: boolean;
  isPreviousDay: boolean;
  expense?: ExpenseForDay;
}

@Component({
  selector: 'app-expenses-calendar',
  imports: [
    LoadingComponent,
    MatButtonToggleModule,
    ExpensesDetailsHeaderComponent
],
  templateUrl: './expenses-calendar.component.html',
  styleUrl: './expenses-calendar.component.scss'
})
export class ExpensesCalendarComponent extends BaseExpensesListComponent {
  readonly viewMode = input<DesktopViewMode>();
  readonly viewModeChanged = output<DesktopViewMode>();
  readonly skeleton = Array.from({ length: 6 }, () => ['100%', '32px']) as [string, string][];
  readonly weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  readonly displayType = signal<'Expected' | 'Actual'>('Actual');
  readonly currentExpensesPrepared = computed(() => this.prepareExpensesForCalendar(this.currentExpenses()!));

  private prepareExpensesForCalendar(model: CurrentExpensesModel): ExpenseForDayWrapper[] {
    const monday = 1;
    const sunday = 0;
    const saturday = 6;
    const expenses = model.expenses.map<ExpenseForDayWrapper>(item => ({
      expense: item,
      isWeekend: item.isWeekend,
      isPreviousDay: item.isPreviousDay,
      monthDay: DATE_UTILS.parse(item.date).getDate()
    }));

    const firstExpenseDate = DATE_UTILS.parse(expenses[0].expense!.date);
    const firstExpenseDay = firstExpenseDate.getDay();
    const lastExpenseDate = DATE_UTILS.parse(expenses[expenses.length - 1].expense!.date);
    const lastExpenseDay = lastExpenseDate.getDay();

    if (firstExpenseDay !== sunday && firstExpenseDay > monday) {
      for (let day = 1; day < firstExpenseDay; day++) {
        const mockDate = DATE_UTILS.add(firstExpenseDate, -day, 'day');
        expenses.unshift({
          autogenerated: true,
          isPreviousDay: true,
          isWeekend: mockDate.getDay() === saturday || mockDate.getDay() === sunday,
          monthDay: mockDate.getDate()
        })
      }
    }

    if (lastExpenseDay !== sunday && lastExpenseDay <= saturday) {
      for (let day = 1; day < lastExpenseDay; day++) {
        const mockDate = DATE_UTILS.add(lastExpenseDate, day, 'day');
        expenses.push({
          isWeekend: mockDate.getDay() === saturday || mockDate.getDay() === sunday,
          isPreviousDay: false,
          monthDay: mockDate.getDate(),
          autogenerated: true
        });
        if (mockDate.getDay() === sunday) break;
      }
    }

    return expenses;
  }
}
